package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {

      def matchAndBind(v: Int, pat: Pattern): (Code, Map[Identifier, Int]) = {
        pat match {
          case WildcardPattern() => (cgExpr(BooleanLiteral(true)), Map())
          case IdPattern(name) =>
            // name = v
            // always true
            (cgExpr(BooleanLiteral(true)), Map(name->v))
          case LiteralPattern(lit) => 
            // v == lit
            (GetLocal(v) <:> cgExpr(lit) <:> Eq, Map())
          case CaseClassPattern(constr, args) =>
            val code = args.zipWithIndex.map{
              case (pat, index) => {
                val id = lh.getFreshLocal
                val (c, map) = matchAndBind(id, pat)
                (GetLocal(v) <:> adtField(index) <:> Load <:> SetLocal(id) <:> c, map)
              }   
            }

            val checkIndex = GetLocal(v) <:> Load <:> Const(table.getConstructor(constr).get.index) <:> Eq
            code.foldLeft((checkIndex, Map[amyc.ast.Identifier,Int]())){
              case ((acc, m1), (code, m2)) => (and(acc, code), m1 ++ m2)
            }
        }

      }

      def ite(cond: Code, thenn: Code, elze: Code): Code =
        cond <:> If_i32 <:> thenn <:> Else <:> elze <:> End  
      def and(lhs: Code, rhs: Code): Code =
        ite(lhs, rhs, Const(0))

      expr match {
        case Variable(name) => GetLocal(locals(name))

        //Literals
        case IntLiteral(value) => Const(value)
        case BooleanLiteral(value) => 
          if(value)
            Const(1)
          else
            Const(0)
        case StringLiteral(value) => mkString(value)
        case UnitLiteral() => Const(0) 

        //BinOps (see import ast.SymbolicTreeModule for AmyXXX names)
        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case AmyAnd(lhs, rhs) => and(cgExpr(lhs), cgExpr(rhs))
        case AmyOr(lhs, rhs) => ite(cgExpr(lhs), Const(1), cgExpr(rhs))
        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)

        //Unary Ops
        case Not(e) => cgExpr(e) <:> Eqz
        case Neg(e) => Const(-1) <:> cgExpr(e) <:> Mul

        case AmyCall(qname, args) => 
          table.getConstructor(qname) match {
            //Function
            case None => 
              args.map(cgExpr(_)) <:> Call(fullName(table.getFunction(qname).get.owner, qname))
            //Constructor
            case Some(constSig) =>
              val memPointer = lh.getFreshLocal()
              val argsStore = (args.map(cgExpr(_)) zip (1 to args.size)).map(as => 
                GetLocal(memPointer) <:> Const(4*as._2) <:> Add <:> as._1 <:> Store)
              GetGlobal(memoryBoundary) <:> SetLocal(memPointer) <:>
              GetGlobal(memoryBoundary) <:> Const(4*(args.size + 1)) <:> Add <:>
              SetGlobal(memoryBoundary) <:> GetLocal(memPointer) <:> 
              Const(constSig.index) <:> Store <:> argsStore <:> GetLocal(memPointer)
          }
        
        case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)
        case Let(df, value, body) =>
          val id = lh.getFreshLocal()
          cgExpr(value) <:> SetLocal(id) <:> cgExpr(body)(locals + ((df.name, id)), lh)

        case Ite(cond, thenn, elze) =>
          ite(cgExpr(cond), cgExpr(thenn), cgExpr(elze))
        
        case Match(scrut, cases) => 
          val v = lh.getFreshLocal()
          // v = scrut
          cgExpr(scrut) <:> SetLocal(v) <:>
          cases.foldRight[Code](cgExpr(Error(StringLiteral("Match error!")))){(mc: MatchCase, acc: Code) => 
            val (code, newLocals) = matchAndBind(v, mc.pat)
            // add code and link locals names
            ite(code, cgExpr(mc.expr)(locals ++ newLocals, lh), acc)
          }


        case Error(msg) => cgExpr(msg) <:> Call("Std_printString") <:> Unreachable 
        
      }

    }

    
    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
